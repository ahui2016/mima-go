# Todo

- 多账号?
- 云储存
- 前后端分离?

## 特色: Alias

- 不提供搜索功能
- 只提供 alias (别名) 快速访问功能
- 不提供顶置 (favorite) 功能, 用别名来取代搜索和顶置
- 原理: 对一个事物命名, 并经常呼唤其名字, 符合人脑的习惯, 自然产生很深刻的记忆
- 顶置的弊端: 随着顶置条目数量增多, 顶置效果变差, 需要经常权衡取消哪些顶置, 增加思维负担

### Alias 允许重复

- 本来的想法是 Alias 不允许重复, 以便快速定位.
- 但今天看到一种需求: 一个条目下需要多个密码, 比如登入密码和更高权限的密码 (支付密码等).
- 如果允许 Alias 重复, 让多个条目共用同一个别名, 即可达到类似于一个条目多个密码的效果.

## 云账号

- 选择 BackBlaze b2 作为云端储存
- 需要由用户自己在 BackBlaze 创建账号, bucket 和 app key
- 第一次上传到云端时, 生成随机用户名, 作为云端的文件夹
- 本地空白数据库可从云端下载数据建立本地数据库 (但需要提供用户名(即云端的文件夹名))
- 虽然有云账号, 但是在设计上并不支持多终端:
  - 只要本地数据库里有数据, 则只能单向从本地向云端上传数据
  - 只有当本地数据库内容为空时, 才能从云端下载数据, 
    但是, 此时会修改用户名 (因此, 再次上传时会上传到云端的新文件夹)

## Write to file

- The `Fprintln` function takes a `io.writer` as parameter and appends a new line.

## Secretbox

- 在 json_test.go 里对加密进行试验.
- 测试多条加密数据的文件读写（换行符的处理）

## 数据库操作符号

- 在 Mima 中增加一个数据库操作符号

## 唯一性检查

- Nonce?
- 由于数据量少, 就用遍历检查.
- 以后数据量大, 可以增加一个 map 来提高效率.

## 自增 ID

- 前端与后端之间相互沟通, 需要指定每一条记录的 ID
- Nonce 是二进制数据, 转换为 base64 也很长, 不适合用来做 ID
- 因此采用自增 ID (uint)
- 自增 ID 难以维护 (需要找一个地方存放 max id), 因此不再使用自增 ID
- 改用 timestamp (短) + [0,100_000_000) 的随机数 (crypto), 再转为 36 进制以缩短字符串长度
  - 经测试, 瞬间生成 10000 个 id 不会重复
  - 由于时间戳的精度为秒, 因此如果两次生成 id 之间超过一秒, 更是绝对不会重复
- 修改代码时发现, 不用自己维护自增 ID, 确实更方便.

## 数据库碎片

- 本软件不采用真正的数据库, 而是使用普通文件来保存信息.
- 每次新增, 修改, 或删除一条记录时, 都生成一个新文件, 称为 "数据库碎片".
- 每次启动软件, 初始化时, 读取这些数据库碎片, 整合到一个单独的文件中.
- 所谓整合, 分两种情况:
  - 如果有修改或删除, 则重写整个文件
  - 如果只有新增, 则直接在文件后 append
- 但鉴于本软件预估数据量很小, 因此不管任何情况都重写整个文件

## 内部数据结构从 list 改为 slice

- 当且只当 Operation.Update 的时候才需要使用 MimaDB.findUpdatedAfter,
  完全不需要用到 insertByUpdatedAt ?
  - 不对, findUpdatedAfter 也不需要使用
  - Add: 永远追加到数组的末尾
  - Delete: 删除, 不需要追加
  - Edit: 更新后, 也是移动到末尾, 不会移动到其他位置
  - 需要确保数据库碎片的文件名按顺序排列, 根据时间先后顺序逐条处理
